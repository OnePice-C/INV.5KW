/**
 * These arguments were used when this file was generated. They will be automatically applied on subsequent loads
 * via the GUI or CLI. Run CLI with '--help' for additional information on how to override these arguments.
 * @cliArgs --device "F28P55x" --part "F28P55x_128PDT" --package "128PDT" --context "system" --product "C2000WARE@5.04.00.00"
 * @v2CliArgs --device "TMS320F28P550SG" --package "128PDT" --variant "TMS320F28P550SG9" --context "system" --product "C2000WARE@5.04.00.00"
 * @versions {"tool":"1.23.0+4000"}
 */

/**
 * Import the modules used in this configuration.
 */
const adc              = scripting.addModule("/driverlib/adc.js", {}, false);
const adc1             = adc.addInstance();
const adc2             = adc.addInstance();
const adc3             = adc.addInstance();
const adc4             = adc.addInstance();
const analog           = scripting.addModule("/driverlib/analog.js", {}, false);
const analog1          = analog.addInstance();
const asysctl          = scripting.addModule("/driverlib/asysctl.js");
const cmpss            = scripting.addModule("/driverlib/cmpss.js", {}, false);
const cmpss1           = cmpss.addInstance();
const cmpss2           = cmpss.addInstance();
const cmpss3           = cmpss.addInstance();
const cmpss4           = cmpss.addInstance();
const device_support   = scripting.addModule("/driverlib/device_support.js");
const ecap             = scripting.addModule("/driverlib/ecap.js", {}, false);
const ecap1            = ecap.addInstance();
const ecap2            = ecap.addInstance();
const epwm             = scripting.addModule("/driverlib/epwm.js", {}, false);
const epwm1            = epwm.addInstance();
const epwm2            = epwm.addInstance();
const epwm3            = epwm.addInstance();
const epwm4            = epwm.addInstance();
const epwm5            = epwm.addInstance();
const epwmxbar         = scripting.addModule("/driverlib/epwmxbar.js", {}, false);
const epwmxbar1        = epwmxbar.addInstance();
const epwmxbar2        = epwmxbar.addInstance();
const epwmxbar3        = epwmxbar.addInstance();
const gpio             = scripting.addModule("/driverlib/gpio.js", {}, false);
const gpio1            = gpio.addInstance();
const gpio2            = gpio.addInstance();
const gpio3            = gpio.addInstance();
const gpio4            = gpio.addInstance();
const gpio5            = gpio.addInstance();
const gpio6            = gpio.addInstance();
const gpio7            = gpio.addInstance();
const gpio8            = gpio.addInstance();
const gpio9            = gpio.addInstance();
const gpio10           = gpio.addInstance();
const gpio11           = gpio.addInstance();
const gpio12           = gpio.addInstance();
const inputxbar_input  = scripting.addModule("/driverlib/inputxbar_input.js", {}, false);
const inputxbar_input1 = inputxbar_input.addInstance();
const inputxbar_input2 = inputxbar_input.addInstance();
const inputxbar_input3 = inputxbar_input.addInstance();
const sync             = scripting.addModule("/driverlib/sync.js");
const sysctl           = scripting.addModule("/driverlib/sysctl.js");
const CMD              = scripting.addModule("/utilities/cmd_tool/cmd_syscfg/source/CMD");
const CMD1             = CMD.addInstance();

/**
 * Write custom configuration values to the imported modules.
 */
adc1.$name                       = "ADC_A";
adc1.soc0IndependentNameMode     = true;
adc1.soc0InputCapacitance        = 300;
adc1.soc0InputResistance         = 300;
adc1.soc0UseCalculatedSampleTime = true;
adc1.soc1InputCapacitance        = 300;
adc1.soc1InputResistance         = 300;
adc1.soc1UseCalculatedSampleTime = true;
adc1.soc1IndependentNameMode     = true;
adc1.soc2IndependentNameMode     = true;
adc1.soc3IndependentNameMode     = true;
adc1.soc2InputCapacitance        = 300;
adc1.soc2InputResistance         = 300;
adc1.soc3InputCapacitance        = 300;
adc1.soc3InputResistance         = 300;
adc1.soc3UseCalculatedSampleTime = true;
adc1.soc2UseCalculatedSampleTime = true;
adc1.soc4IndependentNameMode     = true;
adc1.soc4UseCalculatedSampleTime = true;
adc1.soc4InputResistance         = 100;
adc1.soc4InputCapacitance        = 100;
adc1.soc4SampleWindow            = 15;
adc1.soc5SampleWindow            = 15;
adc1.soc5IndependentNameMode     = true;
adc1.soc2Name                    = "SOC_VS_Boost2";
adc1.soc1Name                    = "SOC_CS_Boost1";
adc1.soc0Name                    = "SOC_CS_Batt2";
adc1.soc3Name                    = "SOC_VS_Batt";
adc1.enabledInts                 = ["ADC_INT_NUMBER1"];
adc1.enableInterrupt1            = true;
adc1.registerInterrupts          = ["1"];
adc1.soc0Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc1.soc1Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc1.soc2Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc1.soc3Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc1.adcClockPrescaler           = "ADC_CLK_DIV_2_0";
adc1.soc1Channel                 = "ADC_CH_ADCIN11";
adc1.soc2Channel                 = "ADC_CH_ADCIN27";
adc1.soc4Name                    = "SOC_VS_Boost1";
adc1.soc4Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc1.soc0Channel                 = "ADC_CH_ADCIN3";
adc1.soc3Channel                 = "ADC_CH_ADCIN6";
adc1.soc4Channel                 = "ADC_CH_ADCIN9";
adc1.soc0SampleWindow            = 15;
adc1.soc1SampleWindow            = 15;
adc1.soc2SampleWindow            = 15;
adc1.soc3SampleWindow            = 15;
adc1.enabledSOCs                 = ["ADC_SOC_NUMBER0","ADC_SOC_NUMBER1","ADC_SOC_NUMBER2","ADC_SOC_NUMBER3","ADC_SOC_NUMBER4","ADC_SOC_NUMBER5"];
adc1.soc5Name                    = "SOC_Vbus_DCDC";
adc1.soc5Channel                 = "ADC_CH_ADCIN28";
adc1.soc5Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc1.adcInt1.enableInterrupt     = true;

adc2.$name                       = "ADC_B";
adc2.adcBase                     = "ADCB_BASE";
adc2.soc0IndependentNameMode     = true;
adc2.soc1IndependentNameMode     = true;
adc2.soc0InputCapacitance        = 300;
adc2.soc0InputResistance         = 300;
adc2.soc0UseCalculatedSampleTime = true;
adc2.soc1InputCapacitance        = 300;
adc2.soc1InputResistance         = 300;
adc2.soc1UseCalculatedSampleTime = true;
adc2.soc2IndependentNameMode     = true;
adc2.soc3IndependentNameMode     = true;
adc2.soc2InputCapacitance        = 300;
adc2.soc2InputResistance         = 300;
adc2.soc2UseCalculatedSampleTime = true;
adc2.soc3InputCapacitance        = 300;
adc2.soc3InputResistance         = 300;
adc2.soc3UseCalculatedSampleTime = true;
adc2.soc4IndependentNameMode     = true;
adc2.soc4InputResistance         = 300;
adc2.soc4UseCalculatedSampleTime = true;
adc2.soc4InputCapacitance        = 300;
adc2.soc5IndependentNameMode     = true;
adc2.soc5InputCapacitance        = 100000;
adc2.soc5InputResistance         = 300;
adc2.soc5UseCalculatedSampleTime = true;
adc2.interruptPulseMode          = "ADC_PULSE_END_OF_CONV";
adc2.soc0SampleWindow            = 15;
adc2.soc1SampleWindow            = 15;
adc2.soc2Name                    = "SOC_BOOST3_VS";
adc2.soc2Channel                 = "ADC_CH_ADCIN2";
adc2.soc2Trigger                 = "ADC_TRIGGER_EPWM1_SOCB";
adc2.soc2SampleWindow            = 15;
adc2.soc3Name                    = "SOC_BOOST4_CS1";
adc2.soc3Trigger                 = "ADC_TRIGGER_EPWM3_SOCA";
adc2.soc3SampleWindow            = 15;
adc2.soc3Channel                 = "ADC_CH_ADCIN12";
adc2.soc4Name                    = "SOC_BOOST4_CS2";
adc2.soc4Channel                 = "ADC_CH_ADCIN12";
adc2.soc4Trigger                 = "ADC_TRIGGER_EPWM3_SOCB";
adc2.soc4SampleWindow            = 15;
adc2.soc5Name                    = "SOC_BOOST4_VS";
adc2.soc5Channel                 = "ADC_CH_ADCIN4";
adc2.soc5Trigger                 = "ADC_TRIGGER_EPWM3_SOCB";
adc2.soc5SampleWindow            = 15;
adc2.soc6Name                    = "SOC_LLC_VS";
adc2.soc6Channel                 = "ADC_CH_ADCIN5";
adc2.soc6Trigger                 = "ADC_TRIGGER_EPWM3_SOCB";
adc2.soc6SampleWindow            = 15;
adc2.soc7Name                    = "SOC_IREF";
adc2.soc7Channel                 = "ADC_CH_ADCIN11";
adc2.soc7Trigger                 = "ADC_TRIGGER_EPWM3_SOCA";
adc2.soc7SampleWindow            = 15;
adc2.soc7IndependentNameMode     = true;
adc2.soc6IndependentNameMode     = true;
adc2.enabledInts                 = ["ADC_INT_NUMBER1"];
adc2.enableInterrupt1            = true;
adc2.registerInterrupts          = ["1"];
adc2.soc1Name                    = "SOC_Vbus";
adc2.soc1Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc2.soc0Name                    = "SOC_IAC";
adc2.enabledSOCs                 = ["ADC_SOC_NUMBER0","ADC_SOC_NUMBER1"];
adc2.soc0Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc2.adcClockPrescaler           = "ADC_CLK_DIV_2_0";
adc2.useInterrupts               = false;
adc2.interrupt1SOCSource         = "ADC_INT_TRIGGER_EOC6";
adc2.soc0Channel                 = "ADC_CH_ADCIN8";
adc2.soc1Channel                 = "ADC_CH_ADCIN26";

adc3.adcBase                     = "ADCC_BASE";
adc3.soc0IndependentNameMode     = true;
adc3.soc0InputCapacitance        = 300;
adc3.soc0InputResistance         = 300;
adc3.soc0UseCalculatedSampleTime = true;
adc3.soc1IndependentNameMode     = true;
adc3.soc1InputCapacitance        = 300;
adc3.soc1InputResistance         = 300;
adc3.soc1UseCalculatedSampleTime = true;
adc3.soc2IndependentNameMode     = true;
adc3.soc2InputCapacitance        = 300;
adc3.soc2InputResistance         = 300;
adc3.soc2UseCalculatedSampleTime = true;
adc3.soc3IndependentNameMode     = true;
adc3.soc3InputCapacitance        = 300;
adc3.soc3InputResistance         = 300;
adc3.soc3UseCalculatedSampleTime = true;
adc3.soc4IndependentNameMode     = true;
adc3.soc4InputResistance         = 10000;
adc3.soc4InputCapacitance        = 100000;
adc3.soc5IndependentNameMode     = true;
adc3.soc5SampleWindow            = 100;
adc3.soc0SampleWindow            = 15;
adc3.soc1SampleWindow            = 15;
adc3.soc2SampleWindow            = 15;
adc3.soc3SampleWindow            = 15;
adc3.soc4Trigger                 = "ADC_TRIGGER_EPWM8_SOCA";
adc3.soc4SampleWindow            = 15;
adc3.soc5Trigger                 = "ADC_TRIGGER_EPWM8_SOCB";
adc3.soc6Name                    = "SOC_TEMP";
adc3.soc6IndependentNameMode     = true;
adc3.soc6Channel                 = "ADC_CH_ADCIN1";
adc3.soc6SampleWindow            = 15;
adc3.soc6Trigger                 = "ADC_TRIGGER_EPWM3_SOCA";
adc3.soc4Channel                 = "ADC_CH_ADCIN11";
adc3.soc5Channel                 = "ADC_CH_ADCIN7";
adc3.soc4Name                    = "SOC_AC_VS";
adc3.soc5Name                    = "SOC_DC_BUS_VS";
adc3.registerInterrupts          = ["1"];
adc3.enabledInts                 = ["ADC_INT_NUMBER1"];
adc3.soc2Name                    = "SOC_VS_Boost1";
adc3.soc2Channel                 = "ADC_CH_ADCIN11";
adc3.soc0Name                    = "SOC_CS_Batt1";
adc3.soc0Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc3.soc1Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc3.soc2Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc3.useInterrupts               = false;
adc3.soc3Name                    = "SOC_VAC";
adc3.soc3Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc3.adcClockPrescaler           = "ADC_CLK_DIV_2_0";
adc3.$name                       = "ADC_C";
adc3.soc3Channel                 = "ADC_CH_ADCIN6";
adc3.soc0Channel                 = "ADC_CH_ADCIN1";
adc3.soc1Name                    = "SOC_VAC";
adc3.enabledSOCs                 = ["ADC_SOC_NUMBER0","ADC_SOC_NUMBER1"];
adc3.soc1Channel                 = "ADC_CH_ADCIN6";

adc4.soc0IndependentNameMode     = true;
adc4.soc0InputCapacitance        = 300;
adc4.soc0InputResistance         = 300;
adc4.soc0UseCalculatedSampleTime = true;
adc4.soc1IndependentNameMode     = true;
adc4.soc1InputCapacitance        = 300;
adc4.soc1InputResistance         = 300;
adc4.soc1UseCalculatedSampleTime = true;
adc4.soc2IndependentNameMode     = true;
adc4.soc2InputCapacitance        = 300;
adc4.soc2InputResistance         = 300;
adc4.soc2UseCalculatedSampleTime = true;
adc4.soc3IndependentNameMode     = true;
adc4.soc3InputCapacitance        = 300;
adc4.soc3InputResistance         = 300;
adc4.soc3UseCalculatedSampleTime = true;
adc4.soc4IndependentNameMode     = true;
adc4.soc4InputResistance         = 10000;
adc4.soc4InputCapacitance        = 100000;
adc4.soc5IndependentNameMode     = true;
adc4.soc5SampleWindow            = 100;
adc4.soc0SampleWindow            = 15;
adc4.soc1SampleWindow            = 15;
adc4.soc2SampleWindow            = 15;
adc4.soc3SampleWindow            = 15;
adc4.soc4Trigger                 = "ADC_TRIGGER_EPWM8_SOCA";
adc4.soc4SampleWindow            = 15;
adc4.soc5Trigger                 = "ADC_TRIGGER_EPWM8_SOCB";
adc4.soc6Name                    = "SOC_TEMP";
adc4.soc6IndependentNameMode     = true;
adc4.soc6Channel                 = "ADC_CH_ADCIN1";
adc4.soc6SampleWindow            = 15;
adc4.soc6Trigger                 = "ADC_TRIGGER_EPWM3_SOCA";
adc4.soc4Channel                 = "ADC_CH_ADCIN11";
adc4.soc5Channel                 = "ADC_CH_ADCIN7";
adc4.soc4Name                    = "SOC_AC_VS";
adc4.soc5Name                    = "SOC_DC_BUS_VS";
adc4.registerInterrupts          = ["1"];
adc4.enabledInts                 = ["ADC_INT_NUMBER1"];
adc4.soc2Name                    = "SOC_VS_Boost1";
adc4.soc2Channel                 = "ADC_CH_ADCIN11";
adc4.soc1Name                    = "SOC_CS_Boost2";
adc4.soc0Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc4.soc1Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc4.soc2Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc4.useInterrupts               = false;
adc4.soc3Name                    = "SOC_VAC";
adc4.soc3Trigger                 = "ADC_TRIGGER_EPWM5_SOCA";
adc4.adcClockPrescaler           = "ADC_CLK_DIV_2_0";
adc4.soc3Channel                 = "ADC_CH_ADCIN6";
adc4.soc1Channel                 = "ADC_CH_ADCIN11";
adc4.$name                       = "ADC_D";
adc4.adcBase                     = "ADCD_BASE";
adc4.enabledSOCs                 = ["ADC_SOC_NUMBER0"];
adc4.soc0Name                    = "SOC_CS_Boost2";
adc4.soc0Channel                 = "ADC_CH_ADCIN15";

asysctl.enableTemperatureSensor = true;
asysctl.analogReference         = "INTERNAL";
asysctl.analogReferenceVoltage  = "1P65";

cmpss1.enableModule  = true;
cmpss1.lowCompInvert = true;
cmpss1.dacValHigh    = 3370;
cmpss1.dacValLow     = 727;
cmpss1.cmpssBase     = "CMPSS2_BASE";
cmpss1.$name         = "myCMPSS_DCAC";

cmpss2.enableModule        = true;
cmpss2.asysCMPHPMXSELValue = "1";
cmpss2.asysCMPLPMXSELValue = "5";
cmpss2.dacValHigh          = 3900;
cmpss2.dacValLow           = 3900;
cmpss2.$name               = "myCMPSS_Boost";

cmpss3.enableModule        = true;
cmpss3.lowCompInvert       = true;
cmpss3.asysCMPLPMXSELValue = "2";
cmpss3.asysCMPHPMXSELValue = "2";
cmpss3.cmpssBase           = "CMPSS4_BASE";
cmpss3.dacValHigh          = 3956;
cmpss3.dacValLow           = 140;
cmpss3.$name               = "myCMPSS_Bidir1";

cmpss4.enableModule        = true;
cmpss4.lowCompInvert       = true;
cmpss4.cmpssBase           = "CMPSS3_BASE";
cmpss4.asysCMPHPMXSELValue = "5";
cmpss4.asysCMPLPMXSELValue = "5";
cmpss4.dacValHigh          = 3956;
cmpss4.dacValLow           = 140;
cmpss4.$name               = "myCMPSS_Bidir2";

analog1.$name            = "myANALOGPinMux0";
adc1.analog              = analog1;
adc2.analog              = analog1;
analog1.useCase          = "CUSTOM";
cmpss1.analog            = analog1;
cmpss2.analog            = analog1;
cmpss3.analog            = analog1;
adc3.analog              = analog1;
adc4.analog              = analog1;
cmpss4.analog            = analog1;
analog1.useInterfacePins = ["A11, B10, C0, PGA2_OUT","A12, C1, E11, PGA3_INP","A14, B14, C4, PGA1_OUT","A27, D9, E9, GPIO212","A28, D19, E19, GPIO215","A3, B3, PGA2_INP, C5, GPIO242","A4, B8, C14","A6, D14, E14, GPIO228","A9, GPIO227","B2, C6, E12, GPIO226","B26, D7, E7","B27, D10, E10, GPIO213","B4, C8, GPIO236","B5, D15, E15, PGA3_OUT"];

ecap1.$name                  = "myECAP0";
ecap1.interruptSourceCapture = ["ECAP_ISR_SOURCE_CAPTURE_EVENT_4"];
ecap1.useInterrupts          = false;
ecap1.eventStop              = "ECAP_EVENT_4";
ecap1.resetCounters          = true;
ecap1.eventOnePolarity       = "ECAP_EVNT_FALLING_EDGE";
ecap1.eventThreePolarity     = "ECAP_EVNT_FALLING_EDGE";
ecap1.counterResetOnEvent    = ["ECAP_EVENT_4"];
ecap1.enableLoadCounter      = true;
ecap1.captureMode            = "ECAP_ONE_SHOT_CAPTURE_MODE";
ecap1.ecapInput              = "ECAP_INPUT_INPUTXBAR1";

ecap2.$name                  = "myECAP1";
ecap2.interruptSourceCapture = ["ECAP_ISR_SOURCE_CAPTURE_EVENT_4"];
ecap2.useInterrupts          = false;
ecap2.eventStop              = "ECAP_EVENT_4";
ecap2.resetCounters          = true;
ecap2.eventOnePolarity       = "ECAP_EVNT_FALLING_EDGE";
ecap2.eventThreePolarity     = "ECAP_EVNT_FALLING_EDGE";
ecap2.counterResetOnEvent    = ["ECAP_EVENT_4"];
ecap2.enableLoadCounter      = true;
ecap2.captureMode            = "ECAP_ONE_SHOT_CAPTURE_MODE";
ecap2.ecapBase               = "ECAP2_BASE";
ecap2.ecapInput              = "ECAP_INPUT_INPUTXBAR7";

epwm1.copyFrom                                                   = "BOOST1";
epwm1.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm1.epwmDeadband_delayRED                                      = 6;
epwm1.epwmDeadband_delayFED                                      = 6;
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_HIGH";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_LOW";
epwm1.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm1.epwmTimebase_emulationMode                                 = "EPWM_EMULATION_FREE_RUN";
epwm1.epwmDeadband_polarityRED                                   = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm1.epwmTimebase_counterModeAfterSync                          = "EPWM_COUNT_MODE_UP_AFTER_SYNC";
epwm1.hrpwm_syncSource                                           = "HRPWM_PWMSYNC_SOURCE_ZERO";
epwm1.epwmTimebase_syncInPulseSource                             = "EPWM_SYNC_IN_PULSE_SRC_DISABLE";
epwm1.$name                                                      = "BOOST";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_UP_CMPB   = "EPWM_AQ_OUTPUT_LOW";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_ON_TIMEBASE_DOWN_CMPB = "EPWM_AQ_OUTPUT_HIGH";
epwm1.epwmTimebase_period                                        = 560;
epwm1.epwm.$assign                                               = "EPWM4";
epwm1.epwm.epwm_aPin.$assign                                     = "GPIO6";

epwm2.copyFrom                                                   = "BOOST1";
epwm2.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm2.epwmDeadband_polarityFED                                   = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm2.epwmDeadband_enableRED                                     = true;
epwm2.epwmDeadband_enableFED                                     = true;
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_HIGH";
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_LOW";
epwm2.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm2.epwmTimebase_emulationMode                                 = "EPWM_EMULATION_FREE_RUN";
epwm2.epwmTimebase_syncInPulseSource                             = "EPWM_SYNC_IN_PULSE_SRC_DISABLE";
epwm2.epwmDeadband_delayRED                                      = 23;
epwm2.epwmDeadband_delayFED                                      = 23;
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_A_onetimeSwForceAction  = "EPWM_AQ_OUTPUT_LOW";
epwm2.epwmTripZone_EPWM_TZ_ACTION_EVENT_DCBEVT1                  = "EPWM_TZ_ACTION_LOW";
epwm2.$name                                                      = "DCAC1";
epwm2.epwmTimebase_period                                        = 840;
epwm2.epwm.epwm_aPin.$assign                                     = "GPIO0";

epwm3.copyFrom                                                   = "BOOST1";
epwm3.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm3.epwmDeadband_polarityFED                                   = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm3.epwmDeadband_enableRED                                     = true;
epwm3.epwmDeadband_enableFED                                     = true;
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_LOW";
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_HIGH";
epwm3.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm3.epwmTimebase_emulationMode                                 = "EPWM_EMULATION_FREE_RUN";
epwm3.epwmTimebase_syncInPulseSource                             = "EPWM_SYNC_IN_PULSE_SRC_DISABLE";
epwm3.epwmDeadband_delayRED                                      = 23;
epwm3.epwmDeadband_delayFED                                      = 23;
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_A_onetimeSwForceAction  = "EPWM_AQ_OUTPUT_LOW";
epwm3.epwmTripZone_EPWM_TZ_ACTION_EVENT_DCBEVT1                  = "EPWM_TZ_ACTION_LOW";
epwm3.$name                                                      = "DCAC2";
epwm3.epwmTimebase_period                                        = 840;
epwm3.epwm.$assign                                               = "EPWM2";
epwm3.epwm.epwm_aPin.$assign                                     = "GPIO2";
epwm3.epwm.epwm_bPin.$assign                                     = "GPIO3";

epwm4.copyFrom                                                   = "BOOST1";
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_LOW";
epwm4.epwmDeadband_enableRED                                     = true;
epwm4.epwmDeadband_enableFED                                     = true;
epwm4.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm4.epwmTimebase_emulationMode                                 = "EPWM_EMULATION_FREE_RUN";
epwm4.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_HIGH";
epwm4.epwmDeadband_polarityFED                                   = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm4.epwmTimebase_syncOutPulseMode                              = ["EPWM_SYNC_OUT_PULSE_ON_CNTR_ZERO"];
epwm4.epwmTimebase_counterModeAfterSync                          = "EPWM_COUNT_MODE_UP_AFTER_SYNC";
epwm4.epwmTimebase_syncInPulseSource                             = "EPWM_SYNC_IN_PULSE_SRC_DISABLE";
epwm4.epwmEventTrigger_EPWM_SOC_A_triggerEnable                  = true;
epwm4.epwmEventTrigger_EPWM_SOC_A_triggerSource                  = "EPWM_SOC_TBCTR_ZERO";
epwm4.epwmEventTrigger_EPWM_SOC_A_triggerEventPrescalar          = "3";
epwm4.epwmDeadband_delayRED                                      = 21;
epwm4.epwmDeadband_delayFED                                      = 21;
epwm4.$name                                                      = "Bidirectional1";
epwm4.epwmTimebase_period                                        = 1120;
epwm4.epwm.$assign                                               = "EPWM5";
epwm4.epwm.epwm_aPin.$assign                                     = "GPIO8";
epwm4.epwm.epwm_bPin.$assign                                     = "GPIO9";

epwm5.copyUse                                                    = true;
epwm5.epwmDeadband_polarityFED                                   = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm5.epwmDeadband_enableRED                                     = true;
epwm5.epwmDeadband_enableFED                                     = true;
epwm5.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm5.epwmTimebase_emulationMode                                 = "EPWM_EMULATION_FREE_RUN";
epwm5.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm5.epwmTimebase_phaseEnable                                   = true;
epwm5.epwmTimebase_syncInPulseSource                             = "EPWM_SYNC_IN_PULSE_SRC_SYNCOUT_EPWM5";
epwm5.epwmTimebase_oneShotSyncOutTrigger                         = "EPWM_OSHT_SYNC_OUT_TRIG_RELOAD";
epwm5.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_LOW";
epwm5.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_HIGH";
epwm5.epwmDeadband_delayRED                                      = 21;
epwm5.epwmDeadband_delayFED                                      = 21;
epwm5.$name                                                      = "Bidirectional2";
epwm5.copyFrom                                                   = "Bidirectional1";
epwm5.epwmTimebase_period                                        = 1120;
epwm5.epwmTimebase_phaseShift                                    = 1118;
epwm5.epwm.$assign                                               = "EPWM6";
epwm5.epwm.epwm_aPin.$assign                                     = "GPIO10";
epwm5.epwm.epwm_bPin.$assign                                     = "A24, D0, E0, GPIO11";

epwmxbar1.$name      = "myEPWMXBAR0";
epwmxbar1.tripInput  = "XBAR_TRIP5";
epwmxbar1.mux6Config = "XBAR_EPWM_MUX06_CMPSS4_CTRIPH_OR_L";
epwmxbar1.mux0Config = "XBAR_EPWM_MUX00_CMPSS1_CTRIPH_OR_L";
epwmxbar1.muxesUsed  = ["XBAR_MUX00"];

epwmxbar2.$name      = "myEPWMXBAR1";
epwmxbar2.tripInput  = "XBAR_TRIP10";
epwmxbar2.mux2Config = "XBAR_EPWM_MUX02_CMPSS2_CTRIPH_OR_L";
epwmxbar2.mux4Config = "XBAR_EPWM_MUX04_CMPSS3_CTRIPH_OR_L";
epwmxbar2.mux6Config = "XBAR_EPWM_MUX06_CMPSS4_CTRIPH_OR_L";
epwmxbar2.muxesUsed  = ["XBAR_MUX04","XBAR_MUX06"];

epwmxbar3.$name      = "myEPWMXBAR2";
epwmxbar3.tripInput  = "XBAR_TRIP12";
epwmxbar3.mux0Config = "XBAR_EPWM_MUX00_CMPSS1_CTRIPH_OR_L";
epwmxbar3.muxesUsed  = ["XBAR_MUX02"];
epwmxbar3.mux2Config = "XBAR_EPWM_MUX02_CMPSS2_CTRIPH_OR_L";

gpio1.initialValue    = 1;
gpio1.direction       = "GPIO_DIR_MODE_OUT";
gpio1.$name           = "RY_ACPreCharge";
gpio1.gpioPin.$assign = "GPIO62";

gpio2.$name             = "RY_DCPreCharge";
gpio2.writeInitialValue = true;
gpio2.direction         = "GPIO_DIR_MODE_OUT";
gpio2.gpioPin.$assign   = "GPIO57";

gpio3.$name             = "Enable_Buffer_ACDC";
gpio3.writeInitialValue = true;
gpio3.initialValue      = 1;
gpio3.direction         = "GPIO_DIR_MODE_OUT";
gpio3.gpioPin.$assign   = "GPIO56";

gpio4.$name             = "Enable_Buffer_DCDC";
gpio4.writeInitialValue = true;
gpio4.initialValue      = 1;
gpio4.direction         = "GPIO_DIR_MODE_OUT";
gpio4.gpioPin.$assign   = "GPIO55";

gpio5.$name             = "Enable_CAN";
gpio5.writeInitialValue = true;
gpio5.direction         = "GPIO_DIR_MODE_OUT";
gpio5.gpioPin.$assign   = "GPIO58";

gpio6.$name             = "Enable_RS485";
gpio6.writeInitialValue = true;
gpio6.direction         = "GPIO_DIR_MODE_OUT";
gpio6.gpioPin.$assign   = "GPIO61";

gpio7.$name           = "TEMP_MUX_A";
gpio7.direction       = "GPIO_DIR_MODE_OUT";
gpio7.gpioPin.$assign = "GPIO34";

gpio8.$name           = "TEMP_MUX_B";
gpio8.direction       = "GPIO_DIR_MODE_OUT";
gpio8.gpioPin.$assign = "GPIO40";

gpio9.$name           = "TEMP_MUX_C";
gpio9.direction       = "GPIO_DIR_MODE_OUT";
gpio9.gpioPin.$assign = "GPIO44";

gpio10.$name           = "TPGPIO24";
gpio10.direction       = "GPIO_DIR_MODE_OUT";
gpio10.gpioPin.$assign = "GPIO60";

gpio11.direction       = "GPIO_DIR_MODE_OUT";
gpio11.$name           = "LED_FAULT";
gpio11.gpioPin.$assign = "GPIO52";

gpio12.$name             = "LED_HEARTBEAT";
gpio12.direction         = "GPIO_DIR_MODE_OUT";
gpio12.writeInitialValue = true;
gpio12.gpioPin.$assign   = "GPIO53";

inputxbar_input1.$name         = "myINPUTXBARINPUT0";
inputxbar_input1.inputxbarGpio = "GPIO51";

inputxbar_input2.$name          = "myINPUTXBARINPUT1";
inputxbar_input2.inputxbarInput = "XBAR_INPUT2";
inputxbar_input2.inputxbarGpio  = "GPIO58";

inputxbar_input3.$name          = "myINPUTXBARINPUT2";
inputxbar_input3.inputxbarInput = "XBAR_INPUT7";
inputxbar_input3.inputxbarGpio  = "GPIO46";

sync.ADCSOCAOutputSelect = ["SYSCTL_ADCSOC_SRC_PWM1SOCA","SYSCTL_ADCSOC_SRC_PWM2SOCA","SYSCTL_ADCSOC_SRC_PWM3SOCA","SYSCTL_ADCSOC_SRC_PWM4SOCA","SYSCTL_ADCSOC_SRC_PWM8SOCA"];
sync.ADCSOCBOutputSelect = ["SYSCTL_ADCSOC_SRC_PWM1SOCB","SYSCTL_ADCSOC_SRC_PWM2SOCB","SYSCTL_ADCSOC_SRC_PWM3SOCB","SYSCTL_ADCSOC_SRC_PWM4SOCB","SYSCTL_ADCSOC_SRC_PWM8SOCB"];

CMD.activateCMD = true;

CMD1.$name                                      = "CMD0";
CMD1.sectionMemory_stack                        = ["RAMM1"];
CMD1.sectionAlignEnable_ramfunc                 = true;
CMD1.sectionRun_ramfunc                         = ["RAMLS0"];
CMD1.sectionRunFromDifferentAddr_ramfunc        = true;
CMD1.sectionAlignEnable_text                    = true;
CMD1.sectionAlignEnable_cinit                   = true;
CMD1.sectionAlignEnable_switch                  = true;
CMD1.sectionAlignEnable_init_array              = true;
CMD1.sectionAlignEnable_const                   = true;
CMD1.sectionMemory_sysmem                       = ["RAMLS5"];
CMD1.sectionAlignEnable_ovly                    = true;
CMD1.sectionAlignEnable_binit                   = true;
CMD1.sectionMemory_codestart                    = "0x080000";
CMD1.sectionMemory_data                         = ["RAMLS5","RAMLS6","RAMLS7"];
CMD1.sectionMemory_bss                          = ["RAMLS5","RAMLS6"];
CMD1.sectionMemory_switch                       = ["FLASH_BANK0"];
CMD1.sectionMemory_const                        = ["FLASH_BANK0"];
CMD1.sectionMemory_init_array                   = ["FLASH_BANK0"];
CMD1.sectionMemory_cinit                        = ["FLASH_BANK0"];
CMD1.sectionMemory_ovly                         = ["FLASH_BANK0"];
CMD1.sectionMemory_binit                        = ["FLASH_BANK0"];
CMD1.sectionMemory_ramfunc                      = ["FLASH_BANK0"];
CMD1.sectionMemory_text                         = ["FLASH_BANK0"];
CMD1.userSection.create(2);
CMD1.userSection[0].$name                       = "dclfuncs";
CMD1.userSection[0].sectionName                 = "dclfuncs";
CMD1.userSection[0].sectionRunFromDifferentAddr = true;
CMD1.userSection[0].sectionRun                  = ["RAMGS1"];
CMD1.userSection[0].sectionAlignEnable          = true;
CMD1.userSection[0].sectionMemory               = ["FLASH_BANK1"];
CMD1.userSection[1].$name                       = "FPUmathTables";
CMD1.userSection[1].sectionName                 = "FPUmathTables";
CMD1.userSection[1].sectionRunFromDifferentAddr = true;
CMD1.userSection[1].sectionRun                  = ["RAMGS1"];
CMD1.userSection[1].sectionAlignEnable          = true;
CMD1.userSection[1].sectionMemory               = ["FLASH_BANK0"];

/**
 * Pinmux solution for unlocked pins/peripherals. This ensures that minor changes to the automatic solver in a future
 * version of the tool will not impact the pinmux you originally saw.  These lines can be completely deleted in order to
 * re-solve from scratch.
 */
analog1.analog.$suggestSolution                                     = "ANALOG";
analog1.analog["a3, b3, pga2_inp, c5, gpio242Pin"].$suggestSolution = "A3, B3, PGA2_INP, C5, GPIO242";
analog1.analog["a4, b8, c14Pin"].$suggestSolution                   = "A4, B8, C14";
analog1.analog["a6, d14, e14, gpio228Pin"].$suggestSolution         = "A6, D14, E14, GPIO228";
analog1.analog["a9, gpio227Pin"].$suggestSolution                   = "A9, GPIO227";
analog1.analog["a11, b10, c0, pga2_outPin"].$suggestSolution        = "A11, B10, C0, PGA2_OUT";
analog1.analog["a12, c1, e11, pga3_inpPin"].$suggestSolution        = "A12, C1, E11, PGA3_INP";
analog1.analog["a14, b14, c4, pga1_outPin"].$suggestSolution        = "A14, B14, C4, PGA1_OUT";
analog1.analog["a27, d9, e9, gpio212Pin"].$suggestSolution          = "A27, D9, E9, GPIO212";
analog1.analog["a28, d19, e19, gpio215Pin"].$suggestSolution        = "A28, D19, E19, GPIO215";
analog1.analog["b2, c6, e12, gpio226Pin"].$suggestSolution          = "B2, C6, E12, GPIO226";
analog1.analog["b4, c8, gpio236Pin"].$suggestSolution               = "B4, C8, GPIO236";
analog1.analog["b5, d15, e15, pga3_outPin"].$suggestSolution        = "B5, D15, E15, PGA3_OUT";
analog1.analog["b26, d7, e7Pin"].$suggestSolution                   = "B26, D7, E7";
analog1.analog["b27, d10, e10, gpio213Pin"].$suggestSolution        = "B27, D10, E10, GPIO213";
epwm1.epwm.epwm_bPin.$suggestSolution                               = "GPIO23";
epwm2.epwm.$suggestSolution                                         = "EPWM1";
epwm2.epwm.epwm_bPin.$suggestSolution                               = "GPIO1";
